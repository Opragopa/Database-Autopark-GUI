import re

RUSSIAN_NAMES = {
    # Имена (мужские и женские)
    "Иван", "Александр", "Сергей", "Андрей", "Дмитрий", "Алексей", "Максим", "Евгений",
    "Павел", "Михаил", "Константин", "Станислав", "Владимир", "Николай", "Юрий", "Виктор",
    "Олег", "Борис", "Илья", "Артём", "Роман", "Арсений", "Марк", "Лев", "Тимофей", "Глеб",
    "Анна", "Мария", "Екатерина", "Ольга", "Наталья", "Елена", "Ирина", "Татьяна",
    "Светлана", "Юлия", "Елизавета", "Виктория", "Анастасия", "Дарья", "Полина", "Алёна",
    "Ксения", "Алина", "Вероника", "Милана", "София", "Арина", "Варвара", "Ульяна"
}

RUSSIAN_SURNAMES = {
    # Фамилии
    "Иванов", "Смирнов", "Кузнецов", "Попов", "Соколов", "Лебедев", "Козлов", "Новиков",
    "Морозов", "Петров", "Волков", "Соловьёв", "Васильев", "Зайцев", "Павлов", "Семёнов",
    "Голубев", "Виноградов", "Богданов", "Воробьёв", "Фёдоров", "Михайлов", "Беляев",
    "Тарасов", "Белов", "Комаров", "Орлов", "Киселёв", "Макаров", "Андреев", "Ковалёв",
    "Ильин", "Гусев", "Титов", "Кузьмин", "Кудрявцев", "Баранов", "Куликов", "Алексеев",
    "Степанов", "Яковлев", "Сорокин", "Сергеев", "Романов", "Захаров", "Борисов", "Королёв",
    "Герасимов", "Пономарёв", "Григорьев", "Лазарев", "Медведев", "Ершов", "Никитин"
}

# Разрешённые буквы для российских номеров (только совпадающие с латиницей)
RUSSIAN_PLATE_LETTERS = "АВЕКМНОРСТУХ"

def validate_russian_plate(plate: str) -> bool:
    """Проверяет соответствие формату российского госномера: А123БВ"""
    if not plate:
        return False
    plate = plate.strip().upper()
    pattern = f"^[{RUSSIAN_PLATE_LETTERS}][0-9]{{3}}[{RUSSIAN_PLATE_LETTERS}]{{2}}$"
    return bool(re.fullmatch(pattern, plate))


def validate_name_part(name: str, part_type: str = "name") -> bool:
    """
    Универсальная валидация ФИО по морфологическим правилам русского языка.

    part_type: 'first' (имя), 'last' (фамилия), 'father' (отчество)
    """
    if not name or len(name) < 2:
        return False

    clean = name.strip().title()

    if not re.fullmatch(r"[А-ЯЁа-яё\-]+", clean):
        return False

    if not re.search(r"[АЕЁИОУЫЭЮЯаеёиоуыэюя]", clean):
        return False

    if part_type == "last":
        return bool(re.search(r"(ов|ев|ин|ын|ский|ской|цкий|цкой|ова|ева|ина|ына|ская|ской|цкая|цкой)$", clean))
    elif part_type == "father":
        return bool(re.search(r"(ович|евич|ич|овна|евна|ична)$", clean))
    else:  # Имя (first)
        return bool(re.search(r"([АЕЁИОУЫЭЮЯ]|ий|ей)$", clean))

# Список реальных городов РФ (для маршрутов)
RUSSIAN_CITIES = {
    "Москва", "Санкт-Петербург", "Новосибирск", "Екатеринбург", "Казань",
    "Нижний Новгород", "Челябинск", "Самара", "Омск", "Ростов-на-Дону",
    "Уфа", "Красноярск", "Воронеж", "Пермь", "Волгоград", "Сочи", "Геленджик",
    "Магадан", "Владивосток", "Иркутск", "Калининград", "Севастополь", "Курск",
    "Тула", "Ярославль", "Набережные Челны", "Тольятти", "Краснодар"
}

def validate_route_name(name: str) -> bool:
    """Проверяет маршрут: либо 'Город-Город', либо простое название"""
    name = name.strip()
    if not name or len(name) < 2:
        return False
    # Замена длинных/коротких дефисов на обычный
    name = name.replace("–", "-").replace("—", "-")
    if "-" in name:
        parts = [p.strip() for p in name.split("-") if p.strip()]
        if len(parts) == 2:
            return parts[0] in RUSSIAN_CITIES and parts[1] in RUSSIAN_CITIES
    return True